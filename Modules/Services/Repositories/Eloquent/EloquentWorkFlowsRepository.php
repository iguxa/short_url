<?php

namespace Modules\Services\Repositories\Eloquent;

use Modules\Services\Http\Services\Nested;
use Modules\Services\Repositories\WorkFlowsRepository;
use Modules\Core\Repositories\Eloquent\EloquentBaseRepository;
use Illuminate\Http\Request;
use Illuminate\Contracts\Pagination\LengthAwarePaginator;
use Kalnoy\Nestedset\Collection as NestedCollection;
use Illuminate\Database\Eloquent\Collection;


class EloquentWorkFlowsRepository extends EloquentBaseRepository implements WorkFlowsRepository
{
    public $default_sorted = 'id';
    public function serverPaginationFilteringFor(Request $request): LengthAwarePaginator
    {
        $pages = $this->allWithBuilder();

        if ($request->get('search') !== null) {
            $term = $request->get('search');
            $pages->whereHas('translations', function ($query) use ($term) {
                $query->where('title', 'LIKE', "%{$term}%");
                $query->orWhere('slug', 'LIKE', "%{$term}%");
            })
                ->orWhere('id', $term);
        }

        if ($request->get('order_by') !== null && $request->get('order') !== 'null') {
            $order = $request->get('order') === 'ascending' ? 'asc' : 'desc';

            if (str_contains($request->get('order_by'), '.')) {
                $fields = explode('.', $request->get('order_by'));

                $pages->with('translations')->join('page__page_translations as t', function ($join) {
                    $join->on('page__pages.id', '=', 't.page_id');
                })
                    ->where('t.locale', locale())
                    ->groupBy('page__pages.id')->orderBy("t.{$fields[1]}", $order);
            } else {
                $pages->orderBy($request->get('order_by'), $order);
            }
        }

        return $pages->paginate($request->get('per_page', 10));
    }
    public function nestedSort(NestedCollection $nodes)
    {
        $response = [];
        $traverse = function (&$categories, $prefix = '--') use (&$traverse, &$response) {
            foreach ($categories as $category) {
                $category->title = $prefix . ' ' . $category->title;
                $response[] = $category;
                $traverse($category->children, $prefix . '--');
            }
        };
        $traverse($nodes);

        return new Collection($response);
    }
    public function update($model, $data)
    {
        $model =  parent::update($model, $data);
        (new Nested())->sort($model, $data['parent']);

        return $model;
    }

    public function create($data)
    {
        return (new Nested())->createNode($data);
    }
    public function destroy($model)
    {
        return (new Nested())->deleteNode($model);
    }
    public function find($id)
    {
        return parent::find($id); // TODO: Change the autogenerated stub
    }
}
